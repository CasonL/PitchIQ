// CallControllerProvider.tsx - React component wrapper for call controller
import React, { createContext, useCallback, useContext, useEffect, useReducer, useRef, useState } from 'react';
import { AudioManager } from './AudioManager';
import { WebSocketManager } from './WebSocketManager';
import { CallMonitoring } from './CallMonitoring';
import { VoiceSelector } from './VoiceSelector';
import { PersonaData } from './DualVoiceAgentFlow';
import { Persona } from '../../types/persona';
import { ProspectCallEventBus } from './ProspectCallEventBus';
import { ProspectCallState, initialCallState, prospectCallReducer } from './ProspectCallState';

// Define a union type that can be either Persona or PersonaData
type PersonaType = Persona | PersonaData;

// Generate a unique session ID
const generateSessionId = (persona: PersonaType): string => {
  const timestamp = Date.now();
  const random = Math.random().toString(36).substring(2, 8);
  return `${persona.name.replace(/\s+/g, '_')}_${timestamp}_${random}`;
};

// Helper function to safely get voiceId from either Persona or PersonaData
const getVoiceId = (persona: PersonaType): string => {
  // For Persona type (backend model)
  if ('voice_id' in persona && typeof persona.voice_id === 'string') {
    return persona.voice_id;
  }
  
  // For any object with voiceId property (frontend model)
  if (persona && typeof persona === 'object' && 'voiceId' in persona && 
      persona.voiceId && typeof persona.voiceId === 'string') {
    return persona.voiceId;
  }
  
  // Default voice ID if none found
  return 'default';
};

// Adapter function to convert PersonaData to Persona or pass through Persona
const adaptPersonaData = (personaData: PersonaData | Persona): Persona => {
  // Check if personaData already has the necessary Persona properties
  if ('id' in personaData && 
      'description_narrative' in personaData && 
      Array.isArray(personaData.personality_traits)) {
    return personaData as unknown as Persona;
  }
  // Handle personality_traits conversion from string to string[]
  let personalityTraits: string[] = [];
  
  if (personaData.personality_traits) {
    if (typeof personaData.personality_traits === 'string') {
      // Split string by commas and trim whitespace
      personalityTraits = personaData.personality_traits
        .split(',')
        .map(trait => trait.trim())
        .filter(trait => trait.length > 0);
    } else if (Array.isArray(personaData.personality_traits)) {
      personalityTraits = personaData.personality_traits;
    }
  }
  
  // If no traits provided, add default lively traits
  if (personalityTraits.length === 0) {
    personalityTraits = ['curious', 'passionate', 'straightforward'];
  }
  
  // Ensure all traits are strings before filtering
  const stringTraits = personalityTraits.map(trait => String(trait));
  
  // Remove any "analytical" traits as per memory
  const filteredTraits = stringTraits.filter(trait => 
    !trait.toLowerCase().includes('analytical') &&
    !trait.toLowerCase().includes('measured') && 
    !trait.toLowerCase().includes('deliberate')
  );
  
  // Replace "analytical" with "thoughtful" in traits
  const transformedTraits = filteredTraits.map(trait => 
    trait.toLowerCase().includes('analytical') ? 
    trait.replace(/analytical/gi, 'thoughtful') : trait
  );
  
  // Final sanitized personality traits array
  personalityTraits = transformedTraits;
  
  // Create a compatible Persona object with default values for missing fields
  const compatiblePersona: Persona = {
    id: `persona_${Date.now()}`,
    name: personaData.name || 'Unknown',
    role: personaData.role || 'Unknown',
    company: personaData.company || 'Unknown',
    description_narrative: 'id' in personaData && 'description_narrative' in personaData 
      ? (personaData as Persona).description_narrative 
      : ((personaData as PersonaData).about_person || ''),
    personality_traits: personalityTraits,
    // Copy other fields that might be useful
    base_reaction_style: 'communication_style' in personaData 
      ? (typeof (personaData as PersonaData).communication_style === 'string' 
        ? (personaData as PersonaData).communication_style as string 
        : '') 
      : '',
    // Handle voice_id safely - use type assertion since we know it might exist
    voice_id: 'voice_id' in personaData ? (personaData as Persona).voice_id : (personaData as any).voice_id
  };
  
  return compatiblePersona;
};

// Event bus will be initialized in the component

// Create context for call controller
interface CallControllerContextValue {
  state: ProspectCallState;
  startCall: (persona: PersonaType, sessionId?: string) => Promise<void>;
  endCall: () => void;
  cleanup: () => void;
  isConnected: boolean;
  isConnecting: boolean;
  callDuration: number;
  transcript: string;
  error: Error | null;
}

const CallControllerContext = createContext<CallControllerContextValue | null>(null);

// Provider component
interface CallControllerProviderProps {
  persona: PersonaType; // Accept either Persona or PersonaData
  onTranscriptUpdate: (text: string) => void;
  children: React.ReactNode;
}

// Define log level type
type LogLevel = 'info' | 'warn' | 'error' | 'debug';

// Define action type for reducer
type CallAction =
  | { type: 'CALL_STARTING' }
  | { type: 'CALL_CONNECTED' }
  | { type: 'CALL_DISCONNECTED' }
  | { type: 'CALL_ENDING' }
  | { type: 'RECONNECT_ATTEMPT' }
  | { type: 'CALL_ERROR'; error: Error };

// Standard function component declaration
export function CallControllerProvider({ 
  persona, 
  onTranscriptUpdate,
  children 
}: CallControllerProviderProps) {
  // State management using useState
  const [state, setState] = useState<ProspectCallState>(initialCallState);
  
  // Refs for managers
  const audioManager = useRef<AudioManager | null>(null);
  const wsManager = useRef<WebSocketManager | null>(null);
  const monitoring = useRef<CallMonitoring>(CallMonitoring.getInstance());
  const eventBus = useRef<ProspectCallEventBus>(ProspectCallEventBus.getInstance());
  
  // Session tracking
  const activeSessionId = useRef<string | null>(null);
  const callStartTime = useRef<number>(0);
  const durationInterval = useRef<number | null>(null);
  const connectionAttempts = useRef<number>(0);
  const maxReconnectAttempts = 2; // Maximum number of reconnection attempts
  
  // Logging utility
  const log = useCallback((message: string, level: string = 'info') => {
    const prefix = activeSessionId.current ? `[${activeSessionId.current}] ` : '';
    console[level === 'error' ? 'error' : level === 'warn' ? 'warn' : 'log'](`${prefix}${message}`);
  }, []);

  // Dispatch function to update state
  const dispatch = useCallback((action: any) => {
    setState(prevState => prospectCallReducer(prevState, action));
  }, []);

  // Handle WebSocket messages
  const handleWebSocketMessage = useCallback((message: any) => {
    if (!message) return;
    
    try {
      // Handle different message types
      if (message.type === 'SpeechStarted') {
        dispatch({ type: 'SENTENCE_PLAYBACK_START' });
      } else if (message.type === 'SpeechFinished') {
        dispatch({ type: 'SENTENCE_PLAYBACK_END' });
      } else if (message.type === 'Speech') {
        // Process speech audio
        if (message.speech && message.speech.data && audioManager.current) {
          const audioData = new Float32Array(message.speech.data);
          audioManager.current.processSentenceAudio(audioData);
        }
      } else if (message.type === 'Transcript') {
        // Update transcript
        if (message.transcript && message.transcript.text) {
          const text = message.transcript.text;
          dispatch({ type: 'UPDATE_TRANSCRIPT', text });
          onTranscriptUpdate(text);
          
          // Record sentence for monitoring
          if (activeSessionId.current) {
            monitoring.current.recordSentence(activeSessionId.current, text);
          }
        }
      } else if (message.type === 'Error') {
        log(`‚ùå Deepgram error: ${message.error}`, 'error');
        dispatch({ type: 'CALL_ERROR', error: new Error(message.error) });
      }
    } catch (error) {
      log(`‚ùå Error processing WebSocket message: ${error}`, 'error');
    }
  }, [dispatch, log, onTranscriptUpdate]);

  // Handle WebSocket errors
  const handleWebSocketError = useCallback((error: Error) => {
    log(`‚ùå WebSocket error: ${error.message}`, 'error');
    
    // Only attempt reconnection if we haven't exceeded the maximum attempts
    if (connectionAttempts.current < maxReconnectAttempts && activeSessionId.current) {
      const attemptNumber = connectionAttempts.current + 1;
      log(`üîÑ Attempting reconnection (${attemptNumber}/${maxReconnectAttempts})`, 'warn');
      connectionAttempts.current = attemptNumber;
      
      // Set a short timeout before reconnecting
      setTimeout(() => {
        // Only attempt reconnection if we still have an active session
        if (activeSessionId.current && wsManager.current) {
          log(`üîå Reconnecting WebSocket for session ${activeSessionId.current}`, 'info');
          try {
            wsManager.current.reconnect();
            log(`‚úÖ Reconnection attempt initiated for session ${activeSessionId.current}`, 'info');
          } catch (reconnectError) {
            log(`‚ùå Reconnection failed: ${reconnectError.message}`, 'error');
            dispatch({ type: 'CALL_ERROR', error: new Error(`Connection failed after ${attemptNumber} attempts. Please try again.`) });
          }
        }
      }, 1000); // 1 second delay before reconnecting
      
      // Show user a reconnection state
      dispatch({ type: 'CALL_RECONNECTING' });
    } else {
      // We've exceeded reconnection attempts, show the error
      dispatch({ type: 'CALL_ERROR', error: new Error(`Connection failed. Please check your internet connection and try again.`) });
      
      if (activeSessionId.current) {
        monitoring.current.recordWebSocketError(activeSessionId.current, error.message);
      }
    }
  }, [dispatch, log]);

  // Handle audio data from microphone
  const handleAudioData = useCallback((audioData: Float32Array) => {
    if (wsManager.current && state.status === 'connected') {
      wsManager.current.sendAudio(audioData);
    }
  }, [state.status]);

  // Start a call
  // Store selected persona for reconnection attempts
  const selectedPersona = useRef<PersonaType | null>(null);
  
  // Define cleanup early to avoid reference issues
  const cleanup = useCallback(() => {
    // Get the current event bus instance
    const currentEventBus = eventBus.current;
    
    // Get active session from event bus instead of local ref
    const sessionBeingClosed = currentEventBus.getActiveSession() || activeSessionId.current;
    log(`üßπ Cleaning up resources for session ${sessionBeingClosed || 'unknown'}`, 'info');
    
    try {
      // Clean up WebSocket resources
      if (wsManager.current) {
        // If we have an active session, send a termination message
        if (sessionBeingClosed) {
          log(`üì§ Sending termination message for session ${sessionBeingClosed}`, 'info');
          wsManager.current.terminate(sessionBeingClosed);
        } else {
          // Reset without termination message if no session ID
          wsManager.current.reset();
        }
        // Set to null to ensure a fresh instance on next connection
        wsManager.current = null;
      } else if (activeSessionId.current && sessionBeingClosed) {
        log(`‚ö†Ô∏è Warning: Cleanup called for session ${sessionBeingClosed} but active session is ${activeSessionId.current}`, 'warn');
      }
      
      // Clean up audio resources
      if (audioManager.current) {
        log(`üé§ üßπ Cleaning up audio resources for session ${sessionBeingClosed || 'unknown'}`, 'info');
        audioManager.current.cleanup();
        audioManager.current = null;
      }
      
      // Clean up monitoring
      if (monitoring.current) {
        monitoring.current.stopPeriodicFlush();
      }
      
      // Remove session from event bus
      log(`üóëÔ∏è Clearing session ${sessionBeingClosed || null} from event bus`);
      currentEventBus.clearActiveSession();
      
      // Reset session state
      activeSessionId.current = null;
      
      // Clear selected persona
      selectedPersona.current = null;
      
      // Clear call duration timer
      if (durationInterval.current) {
        clearInterval(durationInterval.current);
        durationInterval.current = null;
      }
      
      // Reset state
      dispatch({ type: 'CALL_DISCONNECTED' });
    } catch (error) {
      log(`‚ùå Error during cleanup: ${error}`, 'error');
    }
  }, [log, dispatch]);
  
  // Start a call with given persona
  const startCall = useCallback(async (persona: PersonaType, externalSessionId?: string) => {
    // Store the selected persona for potential reconnections
    selectedPersona.current = persona;
    try {
      // Clean up any existing connections before starting new call
      cleanup();
      
      // Use provided external session ID or generate a new one
      const newSessionId = externalSessionId || generateSessionId(persona);
      if (externalSessionId) {
        log(`üîë Using external session ID: ${externalSessionId}`, 'info');
      }
      activeSessionId.current = newSessionId;
      
      log(`üìû Starting call with persona ${persona.name} (session ${newSessionId})`, 'info');
      dispatch({ type: 'CALL_CONNECTING' });
      
      // Reset any previous reconnection attempts
      dispatch({ type: 'RECONNECT_RESET' });
      
      // Initialize monitoring - wrapped in try/catch to ensure metrics failures don't break call flow
      try {
        if (!monitoring.current) {
          monitoring.current = CallMonitoring.getInstance();
        }
        monitoring.current.startCall(newSessionId, persona, getVoiceId(persona));
      } catch (monitoringError) {
        log(`‚ö†Ô∏è Non-critical monitoring error: ${monitoringError}`, 'warn');
        // Continue with the call despite monitoring errors
      }
      
      // Record call start time
      callStartTime.current = Date.now();

      // Set up event bus for this call
      const currentEventBus = eventBus.current;
      currentEventBus.setActiveSession(newSessionId);
      
      // Always create a fresh AudioManager instance with the correct session ID
      // Clean up any existing AudioManager first
      if (audioManager.current) {
        log(`üîä Cleaning up previous AudioManager before creating new one`, 'info');
        audioManager.current.cleanup();
      }
      
      // Create new AudioManager with the fresh session ID
      log(`üîä Initializing new AudioManager for session ${newSessionId}`, 'info');
      audioManager.current = new AudioManager({
        sessionId: newSessionId,
        onAudioData: handleAudioData,
        log: (msg: string) => log(`üé§ ${msg}`)
      });
      
      // Request microphone access with null safety
      if (!audioManager.current) {
        throw new Error('AudioManager not initialized');
      }
      
      // Now safely request microphone access
      const micStream = await audioManager.current.requestMicrophone();
      if (!micStream) {
        throw new Error('Failed to access microphone');
      }
      
      // Set up audio processing
      await audioManager.current.setupAudioProcessing();
      
      // Create WebSocket manager with the persona
      // Store the current session ID in a local constant to ensure it doesn't change
      const stableSessionId = newSessionId;
      
      log(`üîå Creating new WebSocketManager with stable session ID: ${stableSessionId}`, 'info');
      
      // Make sure we're using the current session ID for the WebSocketManager
      // This ensures all WebSocket operations use the same session ID
      wsManager.current = new WebSocketManager({
        sessionId: stableSessionId, // Explicitly use stable ID
        persona: persona,
        voiceId: getVoiceId(persona),
        onMessage: handleWebSocketMessage,
        onError: handleWebSocketError,
        onClose: () => {
          // Use the closure variable to ensure consistent session ID
          log(`üîå WebSocket closed for session ${stableSessionId}`, 'info');
          dispatch({ type: 'CALL_DISCONNECTED' });
        },
        onOpen: () => {
          // Use the closure variable to ensure consistent session ID
          log(`üîå WebSocket opened for session ${stableSessionId}`, 'info');
          dispatch({ type: 'CALL_CONNECTED' });
          
          // Start tracking call duration
          durationInterval.current = window.setInterval(() => {
            const duration = Math.floor((Date.now() - callStartTime.current) / 1000);
            dispatch({ type: 'UPDATE_DURATION', duration });
          }, 1000);
        },
        log
      });
      
      // Explicitly verify session ID consistency before connecting
      if (wsManager.current.getSessionId() !== stableSessionId) {
        log(`‚ö†Ô∏è WebSocketManager session ID mismatch detected, fixing before connection`, 'warn');
        wsManager.current.updateSessionId(stableSessionId);
      }
      
      // Connect to Deepgram using the stable session ID
      log(`üîå Starting connection process for session ${stableSessionId}`, 'info');
      await wsManager.current.connect();
      
      // Double-check that the session ID in the WebSocketManager matches our stable ID
      if (wsManager.current && wsManager.current.getSessionId() !== stableSessionId) {
        log(`‚ö†Ô∏è Session ID mismatch detected: expected ${stableSessionId}, got ${wsManager.current.getSessionId()}`, 'warn');
        // Update the session ID in the WebSocketManager
        wsManager.current.updateSessionId(stableSessionId);
      }
      
      // Send an immediate greeting message to improve realism and engagement
      setTimeout(() => {
        if (wsManager.current && state.status === 'connected') {
          log(`üëã Triggering AI greeting for ${persona.name}`, 'info');
          wsManager.current.sendTextMessage('Hello');
        }
      }, 500); // Short delay to ensure connection is fully established
      
    } catch (error) {
      log(`‚ùå Error starting call: ${error}`, 'error');
      dispatch({ type: 'CALL_ERROR', error: error as Error });
      cleanup();
    }
  }, [handleAudioData, handleWebSocketMessage, handleWebSocketError, log, dispatch]);

  // End a call with robust error handling
  const endCall = useCallback(() => {
    const currentSessionId = activeSessionId.current;
    log(`üìû Ending call with session ID: ${currentSessionId || 'unknown'}`, 'info');
    dispatch({ type: 'CALL_DISCONNECTING' });
    
    try {
      // Record call end in monitoring - safely wrapped
      if (currentSessionId && monitoring.current) {
        try {
          monitoring.current.endCall(currentSessionId, 'user_ended');
        } catch (monitoringError) {
          log(`‚ö†Ô∏è Non-critical monitoring error during call end: ${monitoringError}`, 'warn');
        }
      }
      
      // Broadcast call end event if event bus exists
      if (eventBus.current) {
        eventBus.current.emit('call_ended', { sessionId: currentSessionId });
      }
    } catch (error) {
      log(`‚ö†Ô∏è Error during call end process: ${error}`, 'warn');
      // Continue with cleanup despite errors
    }

  /**
   * End call and clean up resources
   */
  const endCall = useCallback(() => {
    try {
      const currentSessionId = activeSessionId.current;
      log(`üìû Ending call for session ${currentSessionId || 'unknown'}`, 'info');

      // Dispatch end call event
      dispatch({ type: 'CALL_ENDING' });
      
      // End call in monitoring
      if (monitoring.current && currentSessionId) {
        monitoring.current.endCall(currentSessionId, 'user_ended');
      }
      
      // Emit event to event bus
      if (eventBus.current && currentSessionId) {
        eventBus.current.emit('call_ended', { sessionId: currentSessionId });
      }
    } catch (error) {
      log(`‚ö†Ô∏è Error during call end process: ${error}`, 'warn');
      // Continue with cleanup despite errors
    }
    
    // Always attempt to clean up resources
    cleanup();
  }, [log, dispatch]);

  // Cleanup function is now defined earlier in the component

  // Set up event listeners
  useEffect(() => {
    // Listen for external call end events
    const handleExternalCallEnd = () => {
      log('üìû Call ended by external event', 'info');
      cleanup();
    };
    
    eventBus.current.on('call_ended', handleExternalCallEnd);
    
    // Clean up on unmount
    return () => {
      eventBus.current.off('call_ended', handleExternalCallEnd);
      cleanup();
    };
  }, [cleanup, log]);

  // Handle page unload
  useEffect(() => {
    const handleBeforeUnload = () => {
      cleanup();
    };
    
    window.addEventListener('beforeunload', handleBeforeUnload);
    
    return () => {
      window.removeEventListener('beforeunload', handleBeforeUnload);
    };
  }, [cleanup]);

  // Automatic reconnection with enhanced session ID management
  useEffect(() => {
    if (state.status === 'error' && state.reconnectAttempts < 3) {
      const timer = setTimeout(() => {
        // Store the current session ID for logging purposes
        const oldSessionId = activeSessionId.current;
        
        log(`üîÑ Initiating reconnection (attempt ${state.reconnectAttempts + 1}/3)${oldSessionId ? ` after session ${oldSessionId}` : ''}`, 'info');
        
        // Force cleanup of the current session before starting a new one
        cleanup();
        
        // Wait a moment to ensure cleanup is complete
        setTimeout(() => {
          // Double verify WebSocketManager and AudioManager are null after cleanup
          if (wsManager.current) {
            log(`‚ö†Ô∏è WebSocketManager still exists after cleanup, forcing null`, 'warn');
            wsManager.current = null;
          }
          
          if (audioManager.current) {
            log(`‚ö†Ô∏è AudioManager still exists after cleanup, forcing null`, 'warn');
            audioManager.current = null;
          }
          
          // Ensure activeSessionId is null before generating a new one
          if (activeSessionId.current) {
            log(`‚ö†Ô∏è Session ID ${activeSessionId.current} still exists after cleanup, forcing null`, 'warn');
            activeSessionId.current = null;
          }
          
          dispatch({ type: 'RECONNECT_ATTEMPT' });
          
          // Use the current persona for reconnection
          if (selectedPersona.current) {
            // Generate a consistent session ID for the reconnection attempt
            const reconnectSessionId = generateSessionId(selectedPersona.current);
            log(`üîë Generated new session ID for reconnection: ${reconnectSessionId}`, 'info');
            
            // Start call with explicit session ID to ensure consistency
            startCall(selectedPersona.current, reconnectSessionId).catch(error => {
              log(`‚ùå Failed to reconnect: ${error.message}`, 'error');
              dispatch({ type: 'CALL_ERROR', error });
            });
          } else {
            log(`‚ùå Cannot reconnect: No selected persona`, 'error');
            dispatch({ type: 'CALL_ERROR', error: new Error('Cannot reconnect: No selected persona') });
          }
        }, 500); // Wait 500ms after cleanup before starting new connection
      }, 1000 * (state.reconnectAttempts + 1));
      
      return () => clearTimeout(timer);
    }
  }, [state.status, state.reconnectAttempts, startCall, cleanup, log, dispatch, generateSessionId]);

  // Create context value
  const contextValue: CallControllerContextValue = {
    state,
    startCall,
    endCall,
    cleanup,
    isConnected: state.status === 'connected',
    isConnecting: state.status === 'connecting',
    callDuration: state.callDuration,
    transcript: state.transcript,
    error: state.lastError
  };

  return (
    <CallControllerContext.Provider value={contextValue}>
      {children}
    </CallControllerContext.Provider>
  );
} // End CallControllerProvider

// Custom hook to use the call controller context
export function useCallController() {
  const context = useContext(CallControllerContext);
  if (!context) {
    throw new Error('useCallController must be used within a CallControllerProvider');
  }
  return context;
}

